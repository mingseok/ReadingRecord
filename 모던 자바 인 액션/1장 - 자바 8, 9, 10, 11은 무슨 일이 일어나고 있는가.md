## 자바 8, 9, 10, 11은 무슨 일이 일어나고 있는가

자바 8추가된 스트림 API 덕분에 다른 두 가지 기능, 

즉 메서드에 코드를 전달하는 간결 기법(메서드 참조와 람다)과 인터페이스의 디폴트 메서드가 존재 할 수 있음이다.

<br/><br/>

## 스트림 처리

자바 8에는 `java.util.stream` 패키지에 스트림 API가 추가 되었다.

기계적인 예제로 설명하자면, 자동차 생산 공장 라인에 비유할 수 있다.

```
자동차 생산 공장은 여러 자동차로 구성된 스트림을 처리하는데,
각각의 작업장에서는 자동차를 받아서 수리한 다음에, 다음 작업장에서 다른 작업을
처리할 수 있도록 넘겨준다.
```

<br/><br/>


## 동작 파라미터화로 메서드에 코드 전달하기

예를 들어, 2013UK0001, 2014US0002, … 등의 형식을 갖는 송장 ID가 있다고 가정하자.

```
처음 네 개의 숫자는 연도를,
다음 두 글자는 국가 코드를,
마지막 네 개의 숫자는 고객 ID를 의미 한다.
```

이제 나는 이 송장 ID를 고객 ID 또는 국가 코드순으로 정렬해야 한다.



우선은 두 송장 ID를 비교하는 compareUsingId 메서드를 구현할 수 있을 것이다.

<br/>

그런데, 자바 8 이전의 자바에서는 메서드를 다른 메서드로 전달할 방법이 없었다.

하지만, 자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다.

<br/><br/>

## 자바가 진화해야 하는 이유

예를 들어, 갑자기 제네릭이 나타나고, List가 List<String>등으로 바뀌었을 때 당황했을 사람들도 있을 것이다. 

하지만 많은 이가 자바의 변화에 이미 익숙해져 있으며 그것이 가져다 주는 편리함을 누리고 있다.

```
다른 예로, 틀에 박힌 Iterator 대신 for-each 루프를 사용할 수 있게 되었다
```

<br/><br/>

## 일급시민(일급객체)

프로그래밍 언어의 핵심은 값을 바꾸는 것이다.

이 값을 ‘일급값’ 또는 ‘일급 시민’ 이라고 부른다.

<br/>

자바 프로그래밍 언어의 다양한 구조체(메서드, 클래스 같은)가 값의 구조를 표현하는 데 도움이 될 수 있다. 

하지만 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다.

<br/>

이렇게 전달할 수 없는 구조체는 ‘이급 시민’ 이다. 


위에서 언급한 값은 모두 일급 자바 시민이지만 메서드, 클래스 등은 ‘이급 자바 시민’ 에 해당 한다.

<br/><br/>

## JAVA에서는, 함수가 1급 객체에 해당하지 않는다.

```java
public class java {
    public static void test(){
        System.out.println("java");
    }

    public static void main(String[] args) {
        System.out.println("java");
				// Object a = test();
    }
}
```

Kotlin, JavaScript 등의 언어에서는 변수에 함수를 할당하고 사용할 수 있다. 

JAVA는 원래 불가능하지만, JAVA 8 부터는 위 언어들과 같은 1급 객체로의 취급이 가능해진다.

<br/>

## 하지만 이게 중요 할까?

```
정답은 ‘그렇다’ 이다.
```

예를 들어, 런타임에 메서드를 전달할 수 있다면, 

즉 메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용할 수 있다. 

따라서 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가 했다.

<br/><br/>

```
메서드 참조 ::
```

메서드가 아닌 함수라는 용어를 사용했다는 사실도 주목하자.

<br/><br/>

## 람다 : 익명 함수

자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 람다(또는 익명 함수)를 포함하여 함수도 값으로 취급할 수 있다.

예를 들어,

```
(int x) -> x + 1

즉, 'x라는 인수로 호출하면 x + 1 을 반환' 하는 동작을 수행하도록 코드를 구현한다.
```

람다 문법 형식으로 구현된 프로그램을 함수형 프로그래밍, 즉 ‘함수를 일급값으로 넘겨주는 프로그램을 구현한다’ 라고 한다.

<br/><br/>

## 프레디케이트란 무엇인가?

수학에서는 인수로 값을 받아 true나 false를 반환하는 함수를 프레디케이트라고 한다.

`Predicate` 인터페이스는 복잡한 조합이 가능하도록 `negate`, `and`, `or` 세가지 메서드를 제공한다.

```
Function<Apple, Boolean> 같이 코드를 구현할 수 있지만,
Predicate<Apple>을 사용하는 것이 더 표준적인 방식이다.
```

<br/><br/>

## 스트림 API

라이브러리에서 이러한 반복되는 패턴을 제공한다면 좋을 것이라는 아이디어가 변화의 동기가 되었다. 

즉, 자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 `필터링` 하거나, 

데이터를 `추출` 하거나, 데이터를 `그룹화` 하는 등의 기능이 있다. 

<br/>

이러한 동작들을 쉽게 병렬화할 수 있다는 점도 변화의 동기가 되었다.

스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공하는 것이 핵심이다.

<br/>

컬렉션을 필터링할 수 있는 가장 빠른 방법은 컬렉션을 스트림으로 바꾸고, 

병렬로 처리한 다음에, 리스트로 다시 복원하는 것이다.

<br/><br/>

## 디폴트 메서드와 자바 모듈

자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다. 

메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함 된다. (그리하여 이를 디폴트 메서드라고 부른다.)

<br/>

디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다.

```java
default void sort(Comparator<? super E> c) {
		Collections.sort(this, c);
}
```

따라서 자바 8 이전에는 List를 구현하는 모든 클래스가 sort를 구현해야 했지만 자바 8부터는 디폴트 sort를 구현하지 않아도 된다.

<br/><br/>

## Optional<T>

Optional<T>는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체다.

Optional<T>는 값이 없는 상황을 어떻게 처리할지 명시적으로 구현하는 메서드를 포함하고 있다.

따라서 Optional<T>를 사용하면 NullPointer 예외를 피할 수 있다.

<br/><br/>

>**Reference** 
> <br/> [모던 자바 인 액션](http://www.yes24.com/Product/Goods/77125987)