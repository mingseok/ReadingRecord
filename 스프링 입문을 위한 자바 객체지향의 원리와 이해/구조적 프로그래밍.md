## 2장. 자바와 절차적/구조적 프로그래밍

<br/>

## 구조적 프로그래밍이란?

함수를 쓰라는 것이다.

<br/>

중복 코드를 한 곳에 모아서 관리할 수 있고, 논리를 함수 단위로 분리해서 

이해하기 쉬운 코드를 작성할 수 있기 때문이다. 

```java
구조적 프로그래밍의 지침.
공유 사용 시 문제가 발생하기 쉬운 전역 변수보다는 지역 변수를 쓰라는 것.
```

<br/><br/>

## 자바는

자바 개발 도구인 `JDK`를 이용해 개발되고, 개발된 프로그램은 

`JRE`에 의해 컴퓨터의 `JVM`상에서 구동 된다.

```java
JDK - Java Development Kit / 자바 개발 도구 (컴파일러 포함)
JRE - Java Runtime Environment / 자바 실행 환경 (자바 실행기 포함)
JVM - Java Virtual Machine / 자바 가상 기계
```

<br/>

자바 개발자는 본인이 사용 중인 플랫폼에 설치된 `JVM`으로 

프로그램을 작성하고 배포하면 각 플랫폼에 맞는 `JVM`이 알아서 

프로그램을 아무 문제 없이 구동 시켜준다.

- 이러한 자바의 특성을 **"**Write Once Run Anywhere**"** 라고 한다.

<br/><br/>

## 자바의 메모리 사용 방식

- 프로그램이 메모리를 사용하는 방식

    - 코드 실행 영역 / 데이터 저장 영역
- 객체 지향 프로그램의 메모리 사용 방식
    - 코드 실행 영역 / (스태틱 영역, 스택 영역, 힙 영역)
        
        ![이미지](/이미지/참고_이미지.PNG)
        
        데이터 저장 영역에 해당하는 `static` 영역, `stack` 영역, `heap` 영역을 `T 메모리`라고 부른다.




```java
스태틱 영역: 클래스의 놀이터
스택 영역: 메서드의 놀이터
힙 영역: 객체의 놀이터
```

<br/><br/>

## main() 메서드 실행되기 전 JVM에서 수행하는 작업?

메인 메서드가 실행되려면 메인 메서드를 위한 `"스택 프레임"`이 필요하다. 

<br/>

### 스택 프레임이란?

스택 영역을 말하는 것이 아니다.

해당 메서드의 안(?) == `“실행되고 있는 메서드의 공간(도우미)”`이라고 생각하면 된다.

<br/><br/>

이를 스택 영역에 확보해준다.

```java
이후 메서드의 "인자를 저장할 변수공간"을 스택 프레임이 확보한다.
```



간단한 프로그램을 시작하기 위해 `JRE`는 뒤에서 `JVM`이라는 가상 머신을 부팅하고 

`JVM`은 메모리 구조를 만들어 각종 패키지 로딩, 

메인 메서드 스택 프레임 배치, 변수 공간 배치 등의 일을 처리한다.


<br/>

메서드의 끝을 나타내는 닫는 중괄호를 만나면 생성한 `"스택 프레임"`이 사라진다. 

프로그램의 시작점인 메인 메서드가 끝나면 `JRE`는 `JVM`을 종료하고 

`JRE` 자체도 운영체제 상의 메모리에서 사라지게 된다.

<br/><br/>

## 변수와 메모리: 변수! 너 어디 있니?

`main()` 메서드 스택 프레임 안에 밑에서부터 차곡차곡 변수 공간을 마련한다.

```java
public class Start {
  public static void main(String[] args) {
    int i;
    i = 10;
    
    double d = 20.0;
  }
}
```

<br/><br/>

## 변수는 어디에 존재할까?

"변수는 메모리에 존재한다."

변수는 `스택`, `힙`, `스태틱` 영역 3군데 모두에 존재한다.

- 지역 변수는 `스택 프레임` 안에서 생기고, 제거 된다. (=스택 영역)

- 클래스 멤버 변수는 스태틱 영역에서 생기고, 제거 된다.
    - 스태틱 영역에 자리 잡으면 `JVM`이 종료될 때까지, 고정된(static)상태로 영역을 차지한다.
- 객체 멤버 변수는 힙 영역에서 일생을 보낸다.
    - 객체 멤버 변수들은 객체와 함께 `"가비지 컬렉터"`에 의해 제거 된다.

<br/><br/>

## 궁금증.

클래스에 `square()` 메서드가 추가되고, 메인 메서드 실행 도중 `square()`메서드가 

실행되면 메모리 구조는 어떻게 될까?

```java
public class Start {

	private static int square(int k) {
		int result;
		k = 25;
		result = k;

		return result;
	}

	public static void main(String[] args) {
		int k = 5;
		int m;
		m = square(k);
	}
}
```

- `sqaure()`메서드는 새로운 `스택 프레임`을 만든다.

- `square()`메서드의 `k`와 메인 메서드의 `k`는 이름은 같지만,
    
    완전히 다른 변수 공간을 가지므로 서로에게 영향을 주지 않는다. 
    
    이것을 전문 용어로 `“Call By Value"`라 한다.
    
- `square()`의 result 값은 메서드 종료 시 사라지므로 "반환 값"에 복사하고
    
    함수를 종료해야만 메인에서 값을 받을 수 있다.
    
- 메서드의 블랙박스화 -> 입력값과 반환값에 의해서만 메서드 사이에
    
    값이 전달될 뿐 서로 내부의 지역변수를 볼 수 없다. → (이해 안됨)
    

<br/><br/>

## 메서드 간 변수 참조를 금지한 이유

1. 메서드는 자신만의 고유한 공간이므로 침범하면 안된다.

2. 서로의 변수를 참조하려면 위치(주소)를 알아야 하는데 그럴러면 포인터가 필요하다.
3. 포인터가 없어서 메서드간 변수 참조가 불가능하다.

<br/><br/>

## 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!

```java
public class Start {
  static int share;
  
  private static int fun(int m, int p) {
    share = m + p;
    return m - p;
  }

  public static void main(String[] args) {
    share = 55;
    int k = fun(5, 7);
    System.out.println(share);
  }
}
```

코드를 보면 share 변수에 `static` 키워드가 붙어있다. 

그래서 share 변수는 T 메모리의 스태틱 영역에 변수 공간이 할당된다. 

<br/>

전역 변수는 코드 어느 곳에서나 접근할 수 있다고 해서 전역 변수라고 하며, 

여러 메서드들이 공유해서 사용한다고 해서 공유 변수라고도 한다.

<br/>

전역 변수는 피할 수 있다면 즐기지 말고 피해야 할 존재다. 

다만 읽기 전용으로 값을 공유해서 전역 상수로 쓰는 것은 추천한다. 

가장 대표적인 전역 상수 후보로는 원주율을 나타내는 값 등이 있다.

<br/><br/>

## 멀티 스레드 / 멀티 프로세스

### 멀티 스레드

- 멀티스레드는 스택 영역을 분할해서 사용하는 것
- 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의
    
    스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조
    
- 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조

### 멀티 프로세스

- 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조

- 멀티 프로세스 대비 메모리를 적게 사용하는 구조
- 안전한 구조이지만 메모리 사용량은 크다.
- 각 프로세스마다 각자의 T 메모리가 있고 각자 고유의 공간이므로 서로 참조할 수 없는 구조

<br/><br/>

## 효율을 따지자면?

요청당 스레드가 요청당 프로세스(CGI)보다 효율적인 이유는

멀티 쓰레드에서 전역변수 사용은 문제를 발생 시키고 

해결을 위한 `lock`은 멀티스레드의 장점을 버린 것과 같다