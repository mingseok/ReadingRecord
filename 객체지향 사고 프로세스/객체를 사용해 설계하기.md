## 객체를 사용해 설계하기

좋은 객체지향 설계와 나쁜 객체지향 설계를 모두 쉽게 만들 수 있다는 게 진실이다.

<br/>

## 설계 지침

설계 방식이 아니라 메서드 사용법을 어떻게 설계 했느냐다.

좋은 설계를 만드는 데 있어 가장 중요한 요소는 자신과 조직이 편안하게 이를 고수하며 계속 개선하는 과정을 찾는 것이다.

아무도 따르지 않는 설계 과정을 구현하는 것은 의미가 없다.

<br/><br/>

## 객체지향 설계 과정

```
1. 적절한 분석 수행
2. 시스템을 설명 작업명세서 개발
3. 이 작업명세서로부터 요구사항을 수집
4. 사용자 인터페이스용 프로토타입 개발
5. 클래스 식별
6. 각 클래스의 역할을 결정
7. 다양한 클래스가 서로 상호 작용하는 방식을 결정
8. 만들고자 하는 시스템을 설명하는 고급 모델을 구성
```

<br/><br/>

## 코딩을 시작하기 전에 완벽하게 철저하게 설계하는 게 바람직하다.

- 설계 단계에서 요구사항이나 설계를 변경하는 비용이 구현 단계나 배포 단계에서 그러는 경우보다 상대적으로 적다.

- 구현 단계에서는 설계 변경 비용이 상당히 높다.
- 배포 단계 이후에 설계를 변경하려고 할때 드는 비용은 첫 번째 항목과 비교할 때 천문학적이다.

<br/>

## 누군가 빌딩의 설계 문제를 생각하지도 않고 건설했다고 말한다면?

아주 말도 안되는 것이라고 생각 할것이다.

그런데도 사용 중인 소프트웨어에 일부 설계 결함이 있을 수 있으며, 

실제로 철저하게 테스트하지 않았을 수도 있다고 누군가가 말한다고 할지라도 그 사람이 미쳤다고 생각하지는 않는다.

<br/>

### 다른 예제로, 자동차 회사가 리콜에 직면 했을 때 직명하는 딜레마를 생각해보자.

자동차를 출고하 전에 자동차의 결함을 찾아 고칠 때 드는 비용은 출고된 모든 자동차를 한 번에 

하나씩 리콜하고 고쳐야 할 때 드는 비용보다 훨씬 적다. 

<br/>

리콜을 해야 하는 상황에서는 큰 비용을 치러야 할 뿐만 아니라 회사의 명성을 떨어 뜨린다.

그러나 이론상으로는 이것이 항상 목표다.

```
우리는 항상 가능한 많은 버그를 제거하려고 노력해야 한다.
```

<br/><br/>

## 클래스 식별

명사는 사람, 장소, 및 사물과 같은 객체를 나타내는 경향이 있다.

모든 클래스를 처음부터 다 찾아내려고 애쓰지 않도록 한다.

<br/>

그리고 부담감을 내려 놓는 일부터 해야한다.

설계는 반복 과정이라는 사실을 활용하자.

```
최종 결과가 초기에 계획했던 길이 아닌 아주 엉뚱한 길로 흘러갈 수도 있다는 점을 
이해하고 처음에는 부담감을 내려놓는 일부터 하자.
```

<br/><br/>

## 클래스 간 협력 방식 결정

대부분의 클래스는 분리되어 존재하지 않는다.

원하는 것을 얻기 위해 그 밖의 클래스와 상호 작용을 해야 하는 경우가 많다.

<br/>

그렇기 때문에 클래스 간에 메시지가 오가게 된다.

어떤 클래스에 그 밖의 클래스가 지닌 정보가 필요하거나 특정 클래스가 그 밖의 클래스에 어떤 일을 시키려고 한다면, 

해당 클래스가 정보를 제공하거나 일을 대신해 줄 클래스로 메시지를 보내면 된다.

<br/><br/>

## 합성

객체가 그 밖의 객체들을 포함할 수도 있다는 생각은 자연스럽다.

컴퓨터 자체는 객체로 간주될 수 있으며, 플래시디스크도 유효한 객체로 간주된다.

<br/>

컴퓨터를 열고 하드디스크를 분리해 손에 쥐어 볼 수 있다.



하드디스크가 여러 컴퓨터에서 동작할 수 있기 때문에 하드디스크를 확실히 독립적으로 실행되는 객체라고 볼 수 있다.

<br/>

자동차가 객체지향 소프트웨어 시스템을 설계하기 위한 기본 참조점이 된 것은 당연하다.

자동차에 엔진이 들어 있다고 생각할 것이다.

<br/>

그러나, 자동차에는 엔진 외에도 바퀴, 운전대 및 스피커를 포함해 많은 객체가 들어 있다.

특정 객체가 다른 객체로 합성되고 해당 객체가 객체 필드로 포함될 때마다 새 객체를 

```
'복합체'나 '응집체' 또는 '컴포지션'인 객체라고 부른다.
```

<br/><br/>

## 캡슐화가 객체지향의 기본이 되는 이유

캡슐화는 객체지향의 기본 개념이다.

인터페이스/구현부는 패러다임을 다룰 때면 우리는 사실 캡슐화에 대해 이야기하는 것이다.

<br/>

기본적인 질문은 클래스에서 무엇을 노출해야 하고 무엇을 노출해서는 안되는가에 관한 것이다.

어떤 클래스의 설계에 관한 결정을 논의 할때에는 데이터와 행위를 잘 작성된 클래스로 캡슐화하는 일에 초점을 맞춰야 한다.

<br/><br/>

## 상속이 캡슐화를 약화시키는 방법

이미 언급했듯이 캡슐화란 클래스를 공개(public) 인터페이스 부분과 비공개(private) 임플리멘테이션 

부분으로 구분해서 따로따로 모아 두는 과정에 불과하다.

<br/>

본질적으로 클래스는 자신이 아닌 그 밖의 클래스가 알 필요가 없는 모든 것을 숨긴다.

상속으로 인해 그 밖의 클래스에 대해서는 강력하게 캡슐화되는 꼴이 되지만,

정작 슈퍼클래스와 서브클래스 사이의 캡슐화는 약해지는 경우를 말한다.

<br/><br/>

## 문제는

슈퍼클래스에서 구현부를 상속한 후에 해당 구현부를 변경해 버리면 

이러한 슈퍼클래스 내의 변경 내용이 클래스 위계구조를 통해 파급된다는 점이다.

이렇게 줄줄이 전파되는 효과는 잠재적으로 모든 서브클래스에 영향을 미친다.

<br/><br/>

## 결론

합성을 상속보다 많이 써야만 하는 경우라면 그런 생각이 더 적절할 수도 있다.

그런 현실을 고려한다고 해도 무조건 합성만 사용해야 하는 건 아니다.

합성을 쓰는 편이 적절한 경우가 더 많다고 해서 상속이 나쁘다고만은 말할수 없다.

그러므로 합성과 상속을 상황에 맞게 적절히 섞어 쓰도록 하자.


<br/><br/>

>**Reference** 
> <br/> [객체지향 사고 프로세스](http://www.yes24.com/Product/Goods/90688759)