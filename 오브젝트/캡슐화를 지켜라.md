## 캡슐화를 지켜라

데이터 중심의 설계가 낮은 응집도와 높은 결합도라는 문제로 몸살을 앓게 된 

근본적인 원인은 캡슐화의 원칙을 위반했기 때문이다.

<br/>

객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다.

외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.

```
객체에게 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드다.
```



즉, private 메서드로 설정했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화 위반하는 것이다.

<br/>

### 추가로 코드 중복은 악의 근원이다.

따라서 코드 중복을 초래할 수 있는 모든 원인을 제거하는 것이 중요하다.

<br/><br/>

## 스스로 자신의 데이터를 책임지는 객체

상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다.

```
객체는 단순한 데이터 제공자가 아니다.

객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 
수행할 책임을 정의하는 오퍼레이션이 더 중요하다.
```

<br/>

따라서, 객체를 설계할 때 “이 객체가 어떤 데이터를 포함해야 하는가?”라는 질문은 

다음과 같은 두개의 개별적인 질문으로 분리 할 수 있다.

- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

<br/><br/>

## 캡슐화의 진정한 의미

캡슐화가 단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미를 가진다는 것을 잘 보여준다.

사실 캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것을 의미한다.

<br/>

내부 속성을 외부로부터 감추는 것은 ‘데이터 캡슐화’ 라고 불리는 캡슐화의 한 종류일 뿐이다.

```
캡슐화란 변할 수 있는 어떤 것이라도 감추는 것이다.
```

<br/><br/>

## 데이터 중심 설계가 왜 나쁜지 설명

데이터 중심의 설계를 시작할 때 던졌던 질문이 이거다.

```
"이 객체가 포함해야 하는 데이터가 무엇일까?" 
```

데이터는 구현의 일부라는 사실을 명심하자.

<br/>

데이터 중심 설계 방식에 익숙한 개발자들은 일반적으로 데이터와 기능을 

분리하는 절차적 프로그래밍 방식을 따른다.

<br/>

데이터 중심의 관점에서는 접근자와 수정자를 과도하게 추가하게 되고 이 데이터 객체를 사용하는 

절차를 분리된 별도의 객체 안에 구현하게 된다.

<br/>

## 결론적으로 데이터 중심의 설계는

너무 이른 시기에 데이터에 대해 고민하기 때문에 캡슐화에 실패하게 된다.

객체의 인터페이스를 어지럽히고 객체의 응집도와 결합도에 나쁜 영향을 미치기 때문에 변경에 취약한 코드를 낳게 된다.

```
협력이라는 문맥 안에서 필요한 책임을 결정하고 이를 수행할 적절한 
객체를 결정하는 것이 가장 중요하다.
```

<br/>

무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.

객체가 내부에 어떤 상태를 가지고 그 상태를 어떻게 관리하는가는 부가적인 문제다.

중요한 것은 객체가 다른 객체와 협력하는 방법이다.

<br/><br/>

## 데이터 중심 설계의 초점은 객체의 외부가 아니라 내부로 향한다.

실행 문맥에 대한 깊이 있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다.

객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 

이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수 밖에 없다.

```
그에 따라 객체의 내부 구현이 변경됐을때 협력하는 객체 모두가 영향을 받을 수 밖에 없었던 것이다.
```

<br/><br/>

>**Reference** 
> <br/> [오브젝트](http://www.yes24.com/Product/Goods/74219491)