## 협력

```
애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 
어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현에 
초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.
```

객체지향에서 가장 중요한 것은 역할, 책임, 협력이다.

객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 `협력`이라고 한다.

<br/>

객체가 협력에 참여하기 위해 수행하는 로직은 `책임`이라고 부른다.

객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 `역할`을 구성한다.

<br/><br/>

## 협력

협력은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법이다.

두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다.

<br/><br/>

## 메시지 전송

객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다.

객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기 때문에 오직 메시지 전송을 통해서만 자신의 요청을 전달할 수 있다.

```
협력이란? 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다.

한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력 한다.

객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.
```

<br/><br/>

## 메시지를 수신한 객체는 메서드를 실행해 요청에 응답한다.

객체가 메시지를 처리할 방법을 스스로 선택한다는 점이 중요하다.

외부의 객체는 오직 메시지만 전송할 수 있을 뿐이며 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정한다.

```
이것은 객체가 자신의 일을 스스로 처리할 수 있는 자율적인 존재라는 것을 의미한다.
```

<br/><br/>

## 코드에서의 협력 상황

예매 요금을 계산하기 위한 `Screening`과 `Movie`의 협력을 설명한다.

`Screening` 은 `Movie` 에 `calculateMovieFee` 메시지를 전송함으로써 예매자 한명의 요금 계산을 요청한다.

```mermaid
graph LR
A(Screening)-->|calculateMovieFee|B[Movie]
```

<br/><br/>

## 자율적인 객체를 만드는 기본적인 방법은 캡슐화이다.

`Screening` 이 요금을 계산하기 위해 `Movie` 의 내부 구현에 직접 접근한다는 것은 캡슐화의 원칙을 위반한다는 것을 의미한다.

이 경우 `Movie` 의 내부 구현을 바꾸면 `Screening` 도 영향을 받게 된다.

```
반면, `Movie` 가 자신의 정보를 바탕으로 요금을 직접 계산하면 
`Screening` 과 `Movie` 사이의 결합도는 느슨하게 유지할 수 있고, 
`Movie` 에 대한 변경의 여파가 `Screening` 쪽으로 확산되는 것을 막을 수 있다.
```

<br/><br/>

## 지금까지 정리.

자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 

적절한 객체에게 메시지를 전송해서 협력을 요청한다.

<br/>

메시지를 수진한 객체 역시 메시지를 처리하던 중에 직접 처리할 수 없는 

정보나 행동이 필요한 경우 또 다른 객체에게 도움을 요청한다.

<br/><br/>

## 협력이 설계를 위한 문맥을 결정한다.

```
"객체가 가질 수 있는 상태와 행동을 어떤 기준으로 결정해야 할까?"

"객체를 설계할 때 어떤 행동과 상태를 할당했다면 그 이유는 무엇인가?"
```

애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다.

그리고 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 때문이다.

<br/><br/>

## Movie 객체는 어떤 행동을 수행할 수 있어야 할까?

영화라는 단어를 들었을 때 대부분의 사람들은 극장에서 영화를 상영하는 장면을 상상할 것이고 

자연스럽게 `Movie`객체가 `play`라는 행동을 수행할 것이라고 생각한다.

```
그러나 영화 예매 시스템 안의 Movie에는 영화를 상영하기 위한 어떤 코드도 포함돼있지 않다.
```

<br/>

Movie에 포함된 대부분의 메서드는 요금을 계산하는 행동과 관련된 것이다.

이것은, Movie가 영화를 예매하기 위한 협력에 참여하고 있고 그 안에서 요금을 계산하는 책임을 지고 있기 때문이다.

<br/>

### Movie의 행동을 결정하는 것은 영화 예매를 위한 협력이다.

협력이라는 문맥을 고려하지 않고 `Movie`의 행동을 결정하는 것은 아무런 의미가 없다.

협력이 존재하기 때문에 객체가 존재하는 것이다.

```
객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.
```



자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다.

<br/><br/>

## Movie 코드

Movie가 기본 요금인 `fee`와 할인 정책인 `discountPolicy` 라는 인스턴스 변수를 상태의 일부로 포함하는 이유는 

요금 계산이라는 행동을 수행하는데 이 정보들이 필요하기 때문이다.

```java
public class Movie {
    private Money fee;
    private DiscountPolicy discountPolicy;

    public Movie(Money fee, DiscountPolicy discountPolicy) {
        this.fee = fee;
        this.discountPolicy = discountPolicy;
    }

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

<br/><br/>

## 상태

객체가 행동하는데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정된다. 

협력이 객체를 구성하는 행동과 상태 모두를 결정한다. 

따라서 협력은 객체를 설계하는 데 필요한 일종의 문맥을 제공하는 것이다.

<br/><br/>

>**Reference** 
> <br/> [오브젝트](http://www.yes24.com/Product/Goods/74219491)