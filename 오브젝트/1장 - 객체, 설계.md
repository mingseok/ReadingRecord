## 객체, 설계

## 티켓 판매 애플리케이션 구현하기

```
이벤트에 당첨된 관람객과 그렇지 못한 관람객은 다른 방식으로 입장 시켜야 한다는 것이다.
이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후에 입장할 수 있다.
이벤트에 당첨되지 않은 관람객은 티켓을 구매해야만 입장할 수 있다.
```

따라서, 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인해야 하고, 

이벤트 당첨자가 아닌 경우에는 티켓을 판매한 후에 입장시켜야 한다.

[(LINK) 코드 구현](https://github.com/mingseok/Java-Spring-Lab)


<br/><br/>

## 이해 가능한 코드란?

이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드이다.

```
현실에서는 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건넨다.

티켓을 구매하는 관람객은 가방 안에서 돈을 직접 꺼내 판매원에게 지불한다.
판매원은 매표소에 있는 티켓을 직접 꺼내 관람객에게 건네고,
관람객에게서 직접 돈을 받아 매표소에 보관한다. 
```

하지만 코드 안의 관람객, 판매원은 그렇게 하지 않는다.

우리의 상식과는 너무나도 다른게 동작하기 때문에 코드를 읽는 사람과 제대로 의사소통하지 못한다.

<br/><br/>

## 코드를 이해하기 어렵게 만드는 또 다른 이유

코드를 이해하기 위해서는 여러가지 세부적인 내용들을 헌꺼번에 기억하고 있어야 한다는 점이다.

```
'극장' 클래스의 enter() 메서드를 이해하기 위해서는, 
'관람객' 클래스가 Bag을 가지고 있고, Bag 안에는 현금과 티켓이 들어 있으며, 
'티켓 판매자' 클래스가 '매표소' 클래스에서 티켓을 판매하고, 
'매표소' 클래스 안에 돈과 티켓이 보관돼 있다는 모든 사실을 동시에 기억해야 된다는 것이다.
```

하나의 클래스나 메서드에서 너무 많은 세부사항을 다루기 때문에 코드를 작성하는 사람뿐만 아니라 

코드를 읽고 이해해야 하는 사람 모두에게 큰 부담을 준다는 것이다.

<br/><br/>

## 변경에 취약한 코드

지금까지의 코드를 보자면 관람객이 현금과 초대장을 보관하기 위해 항상 가방을 들고 다닌다는 것이다. 

또한 판매원이 매표소에서만 티켓을 판매한다고 가정하고 있다.

```
관람객이 가방을 들고 있지 않다면 어떻게 해야 할까?

관람객이 현금이 아니라 신용카드를 이용해서 결제 한다면 어떻게 해야 할까?

판매원이 매표소 밖에서 티켓을 판매해야 한다면 어떻게 해야 할까?
```

지나치게 세부적인 사실에 의존해서 동작하는 것이다. 

<br/>

그렇게 된다면 모든 코드가 흔들리게 되는 것이다.

이것은 객체 사이의 의존성과 관련된 문제이다.

<br/><br/>

## 객체 사이의 의존성

의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.

객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다.

<br/>

목표는 

```
애플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 
불필요한 의존성을 제거하는 것이다.
```

<br/><br/>

## 결합도

객체 사이의 의존성이 과한 경우를 가리켜 ‘결합도가 높다’ 고 말한다.

반대로 객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낮다고 말한다.

<br/>

결합도는 의존성과 관련돼 있기 때문에 결합도 역시 변경과 관련이 있다.

따라서 설계의 목표

```
객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이다.
```

<br/><br/>

## 설계 개선하기

'극장' 클래스가 '관람객' 클래스와 '티켓 판매자'에 관해 너무 세세한 부분까지 알지 못하도록 정보를 차단하면 된다. 

```
사실 관람객이 가방을 가지고 있다는 사실과 판매원이 매표소에서 티켓을 판매한다는 
사실을 ‘극장’ 클래스가 알아야 할 필요가 없다.
```

‘극장’ 클래스가 원하는 것은 관람객이 소극장에 입장하는 것뿐이다.

<br/>

따라서 관람객이 스스로 가방 안의 현금과 초대장을 처리하고, 

판매원이 스스로 매표소의 티켓과 판매 요금을 다루게 한다면 

이 모든 문제를 한 번에 해결할 수 있게 되는 것이다.

<br/><br/>

## 자율성을 높이자

```
설계를 변경하기 어려운 이유는?
```

‘직장’ 클래스가 ‘관람객’ 과 ‘티켓 판매자’ 뿐만 아니라 ‘관람객’의 Bag과 ‘티켓 판매자’의 근무하는 

‘매표소’까지 마음대로 접근할 수 있기 때문이다. 

<br/>

해결 방법은 ‘관람객’과 ‘티켓 판매자’가 직접 Bag과 매표소를 처리하는 자율적인 존재가 되도록 설계해야 하는 것이다.

<br/><br/>

## 캡슐화

캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.

캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에

설계를 좀 더 쉽게 변경할 수 있게 된다.

<br/><br/>

## 바뀐 코드

```java
public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        ticketSeller.sellTo(audience);
    }
}
```

Theater(극장) 클래스 어디에도 TicketOffice(매표소) 클래스에 접근하지 않는다는 사실을 주목해보자.

Theater(극장) 클래스가 TicketSeller(티켓 판매자) 클래스 내부에 존재한다는 사실을 알지 못한다.

<br/>

Theater(극장)는 단지 TicketSeller(티켓 판매자) 클래스 가 sellTo() 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐이다.

```
Theater(극장) 클래스는 오직 TicketSeller(티켓 판매자)의 인터페이스에만 의존한다.

TicketSeller(티켓 판매자)가 내부에 TicketOffice(매표소) 인스턴스를 포함하고 있다는 사실은
구현의 영역에 속한다.
```

<br/>

객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 

변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.

<br/><br/>

## 무엇이 개선되었는가?

Audience나 TicketSeller의 내부 구현을 변경하더라도 Theater를 한께 변경할 필요가 없어졌다는 것이다.

```
Audience가 가방이 아니라 작은 지갑을 소지하도록 코드를 변경하고 싶은가?
-> Audience 내부만 변경하면 된다.

TicketSeller가 매표소가 아니라 은행에 돈을 보관하도록 만들고 싶은가?
-> TicketSeller 내부만 변경하면 된다.
```

두 경우 모두 변경은 Audience와 TicketSeller 내부만으로 제한된다.

따라서, 수정된 코드는 변경 용이성의 측면에서도 확실히 개선 되었다.

<br/><br/>

## 어떻게 한 것일까?

판매자가 티켓을 판매하기 위해 TicketOffice를 사용하는 모든 부분을 TicketSeller 내부로 옮기고,

관람객이 티켓을 구매하기 위해 Bag을 사용하는 모든 부분을 Audience 내부로 옮긴 것이다.

```
다시 말해 자기 자신의 문제를 스스로 해결하도록 코드를 변경한 것이다.
```

<br/><br/>

## 캡슐화와 응집도

핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다. 

Theater는 TicketSeller의 내부에 대해서는 전혀 알지 못한다.

<br/>

단지, TicketSeller가 sellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐이다.

TicketSeller 역시 Audience의 내부에 대해서는 전혀 알지 못한다.

<br/>

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다.

자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을 뿐더러 응집도를 높일 수 있다.

```
메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 
훌륭한 객체지향 설계를 얻을 수 있는 지름길이다.

훌륭한 객체지향 설계의 핵심은 캡술화를 이용해 의존성을 적절히 관리함으로써 
객체 사이의 결합도를 낮추는 것이다.
```

<br/><br/>

## 책임의 이동

```
객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다.
```

따라서, 각 객체는 자신을 스스로 책임진다.

<br/>

객체가 어떤 데이터를 가지느냐보다는 객체에 어떤 책임을 할당할 것이냐에 초점을 맞춰야 한다.

```
TicketSeller의 책임은 무엇인가?
티켓을 판매하는 것이다.

Audience의 책임은 무엇인가?
티켓을 사는 것이다.

Theater의 책임은 무엇인가?
관람객을 입장 시키는 것이다.
```

적절한 객체에 적절한 책임을 할당하면 이해하기 쉬운 구조와 읽기 쉬운 코드가 된다.

<br/><br/>

## 설계를 어렵게 만드는 것은 의존성

해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다.

결합도를 낮추기 위해 선택한 방법은 Theater 가 몰라도 되는 세부사항을 Audience와 TicketSeller 내부로 감춰 캡슐화하는 것이다.

<br/>

불필요한 세부사항을 객체 내부로 캡슐화하는 것은 객체의 자율성을 높이고 응집도 높은 

객체들의 공동체를 창조할 수 있게 된다.

<br/>

불필요한 세부사항을 캡슐화하는 자율적인 객체들이 낮은 결합도와 높은 응집도를 가지고 

협력하도록 최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계이다.

<br/><br/>

## 두 가지 사실을 기억하자

```
1. 어떤 기능을 설계하는 방법은 한가지 이상일 수 있다.
2. 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 
   결국 설계는 트레이드오프의 산물이다.
```

어떤 경우에도 모든 사람들을 만족시킬 수 있는 설계를 만들 수는 없다.

<br/><br/>

## 이해하기 쉽고 변경하기 쉬운 코드를 작성하고 싶다면

한 편의 애니메이션을 만든다고 생각하자.

다른 사람의 코드를 읽고 이해하는 동안에는 애니메이션을 보고 있다고 뇌를 속여 보는 것이다.

그렇게 하면 코드 안에서 웃고, 떠들고, 화내는 가방 객체를 만나더라도 당황하지 않을 것이다.

<br/><br/>

>**Reference** 
> <br/> [오브젝트](http://www.yes24.com/Product/Goods/74219491)