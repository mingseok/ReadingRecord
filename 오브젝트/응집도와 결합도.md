## 응집도와 결합도

## 응집도

모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.

모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 `높은 응집도`를 가진다.

모듈 내의 요소들이 서로 다른 목적을 추구한다면 그 모듈은 `낮은 응집도`를 가진다.

```
객체지향의 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당 했는지를 나타낸다.
```

<br/><br/>

## 결합도

의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.

어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 `높은 결합도`를 가진다.

어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 `낮은 결합도`를 가진다.

```
객체지향의 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 
관계만을 유지하고 있는지 나타낸다.
```

<br/>

### 궁금증

애매한 설명만으로는 응집도와 결합도의 의미를 명확하게 이해하기 어렵다.

```
모듈 내의 요소가 얼마나 강하게 연관돼 있어야 응집도가 높다고 말할 수 있는가?

모듈 사이에 어느 정도의 의존성만 남겨야 결합도가 낮다고 말할 수 있는가?
```

<br/><br/>

## 응집도와 결합도를 이해하기 위한 첫걸음

두 개념 모두 설계와 관련 있다.

```
일반적으로 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.
```

다시 말해, 애플리케이션을 구성하는 각 요소의 `응집도가 높고` 서로 `느슨하게 결합`돼 있다면 

그 애플리케이션은 좋은 설계를 가졌다고 볼 수 있다.

<br/><br/>

## 좋은 설계란?

오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다.

응집도와 결합도는 변경과 관련된 것이다.

<br/>

높은 응집도와 낮은 결합도를 가진 설계를 추구해야 하는 이유는 단 한가지다.

```
설계를 변경하기 쉽게 만들기 때문이다.
```

<br/><br/>

## 변경의 관점에서 응집도란?

변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.

<br/>

간단히 말해, 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 `응집도가 높은` 것이고 

모듈의 일부만 변경된다면 `응집도가 낮은` 것이다. 

<br/>

또한 하나의 변경에 대해 하나의 모듈만 변경된다면 `응집도가 높지`만 다수의 모듈이 함께 변경돼야 한다면 `응집도가 낮은` 것이다.

밑에 그림은 응집도가 낮은 설계를 나타낸다. (이렇게 하면 X)

![이미지](/img/오브젝트8.PNG)

<br/>

밑에 그림은 응집도가 높은 설계를 나타낸다.

그리하여 밑에 처럼 응집도가 높은 설계를 해야한다.

![이미지](/img/오브젝트9.PNG)

응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다.

<br/>

변경으로 인해 수정되는 부분을 파악하기 위해 코드 구석구석 해매고 다니거나 

여러 모듈을 동시에 수정할 필요가 없으며 변경을 반영하기 위해 오직 하나의 모듈만 수정하면 된다.

<br/><br/>

## 변경의 관점에서 결합도란?

결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.

다시 말해, 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는지 나타낸다.

<br/>

결합도가 높을수록 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기가 어려워진다.

밑에 그림은 낮은 결합도를 가진 것이다. (우리는 이렇게 설계해야 한다.)

<br/>

A를 변경했을 때 오직 하나의 모듈만 영향을 받는다는 것을 알 수 있다.

![이미지](/img/오브젝트10.PNG)

<br/>

반면, 높은 결합도를 가진 밑에 그림은

모듈 A를 변경했을 때 4개의 모듈을 동시에 변경해야 한다.

![이미지](/img/오브젝트11.PNG)

내부 구현을 변경했을 때 이것이 다른 모듈에 영향을 미치는 경우에는 두 모듈 사이의 결합도가 높다고 표현한다. 

반면, 퍼블릭 인터페이스를 수정 했을 때만 다른 모듈에 영향을 미치는 경우에는 결합도가 낮다고 표현한다.

<br/>

따라서 클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.

다시 강조하지만 응집도와 결합도는 `변경`과 관련이 깊다.

<br/>

어떤 설계를 쉽게 변경할 수 있다면 높은 응집도를 가진 요소들로 구성돼 있고 요소들 사이의 결합도가 낮을 확률이 높다.

```
캡슐화의 정도가 응집도와 결합도에 영향을 미친다는 사실을 강조한다.
```

<br/>

캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다.

캡슐화를 위반하면 모듈 사이의 결합도는 높아진다.

<br/><br/>

## 캡슐화 위반

밑에 코드는 직접 객체의 내부에 접근할 수 없기 때문에 캡슐화의 원칙을 지키고 있는 것처럼 보인다.

“정말 그럴까?” 하지만,  틀렸다.

<br/>

접근자와 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다.

getFee() 와 setFee()는 Movie 내부에 Money 타입의 fee라는 이름의 인스턴스 변수가 존재한다는 

사실을 퍼블릭 인터페이스로 노골적으로 드러내고 있기 때문이다.

```java
public class Movie {
    private Money fee;

    public Money getFee() {
        return fee;
    }

    public void setFee(Money fee) {
        this.fee = fee;
    }
}
```

<br/><br/>

## 높은 결합도

영화 예매 시스템을 예로 말하자면,

데이터 중심의 설계는 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어 버리기 때문에 

어떤 변경이라도 일단 발생하고 나면 시스템 전체가 요동칠 수밖에 없다.

<br/><br/>

## 낮은 응집도

서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.

변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 된다.

<br/>

어떤 코드를 수정한 후에 아무런 상관도 없던 코드에 문제가 발생하는 것은 모듈의 응집도가 낮을 때 발생하는 대표적인 증상이다.

어떤 요구사항 변경을 수용하기 위해 하나 이상의 클래스를 수정해야 하는 것은 설계의 응집도가 낮다는 증거다.

<br/><br/>

## 단일 책임 원칙(SRP)

한마디로 요약하면 클래스는 단 한 가지의 변경 이유만 가져야 한다는 것이다.

단일 책임 원칙이 클래스의 응집도를 높일 수 있는 설계 원칙이다.

단일 책임 원칙이라는 맥락에서 ‘책임’이라는 말이 ‘변경의 이유’라는 의미로 사용된다는 점이다.

<br/>



<br/><br/>

>**Reference** 
> <br/> [오브젝트](http://www.yes24.com/Product/Goods/74219491) <br/><br/>
>그림 참조 - [https://blogshine.tistory.com/225](https://blogshine.tistory.com/225)