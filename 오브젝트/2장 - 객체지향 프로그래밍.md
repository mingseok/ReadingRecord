## 객체지향 프로그래밍

## 영화 예매 시스템

```
사용자는 영화 예매 시스템을 이용해 쉽고 빠르게 보고 싶은 영화를 예매할 수 있다.
```

[(LINK) 코드 구현](https://github.com/mingseok/Java-Spring-Lab)

<br/><br/>

## 협력, 객체, 클래스

```
객체지향은 객체를 지향하는 것이다.
```

객체지향 언어에 익숙한 사람이라면 가장 먼저 어떤 클래스가 필요한지 고민할 것이다.

대부분의 사람들은 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 고민한다.

<br/>

### 안타깝게도 이것은 객체지향의 본질과는 거리가 멀다.

진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.

<br/><br/>

## 두 가지에 집중하자.

첫번째. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.

```
클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다.
따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정한다.
```

<br/>

두번째. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.

```
객체는 홀로 존재하는 것이 아니다.
다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존재다.

객체지향적으로 생각하고 싶다면 객체를 고립된 존재로 바라보지 말고, 
협력에 참여하는 협력자로 바라보기 바란다.

객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 
타입으로 분류하고 이 타입을 기반으로 클래스를 구현하라.

```

<br/><br/>

## 도메인의 구조를 따르는 프로그램 구조

영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것이다.

이처럼, 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 한다.

<br/><br/>

## 자율적인 객체

두 가지를 알고 있어야 한다.

1. 객체가 상태와 행동을 함께 가지는 복합적인 존재라는 것이다.

2. 객체가 스스로 판단하고 행동하는 자율적인 존재라는 것이다.

<br/><br/>

## 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 부른다.

캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.

하나는 외부에서 접근 가능한 부분으로 이를 ‘퍼블릭 인터페이스’ 라고 부른다.

<br/>

다른 하나는 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 ‘구현’ 이라고 부른다.

```
‘인터페이스와 구현의 분리’는 핵심 원칙이다.
```

<br/><br/>

## 협력에 관한 짧은 이야기

객체의 내부 상태는 외부에서 접근하지 못하도록 감춰야 한다.

대신 외부에 공개하는 퍼블릭 인터페이스를 통해 내부 상태에 접근할 수 있도록 허용한다.

<br/>

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것뿐이다.

다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신 했다고 이야기 한다.

```
수신된 메시지를 처리하기 위한 자신만의 방법을 '메서드' 라고 부른다.
```

<br/>

### 코드에서

`Screening`이 `Movie`의 `calculateMovieFee` ‘메서드를 호출한다’고 말했지만 사실은

`Screening`이 `Movie`에게 `calculateMovieFee` ‘메세지를 전송한다’ 라고 말하는 것이 더 적절하다.

<br/><br/>

## 컴파일 시간 의존성과 실행 시간 의존성

설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억하자.

반면, 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다는 사실도 기억하자.

```
무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다.
```

<br/><br/>

## 다형성

```
다시 한번 강조하지만 메시지와 메서드는 다른 개념이다.
```

그렇다면 실행되는 메서드는 무엇인가?

Movie와 상호작용하기 위해 연결된 객체의 클래스가 무엇인가에 따라 달라진다.

<br/>

Movie와 협력하는 객체가 `AmountDiscountPolicy` 의 인스턴스라면 

`AmountDiscountPolicy` 에서 오버라이딩한 메서드가 실행될 것이다.

<br/>

또, `PercentDiscountPolicy` 의 인스턴스가 연결된 경우에는

`PercentDiscountPolicy` 에서 오버라이딩한 메서드가 실행될 것이다.

<br/>

다시 말해서 Movie는 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 

메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.

```
이를 '다형성'이라고 부른다.
```

<br/>

다형적인 협력에 참여하는 객체들을 모두 같은 메시지를 이해할 수 있어야 한다.

다시 말해, 인터페이스가 동일해야 한다는 것이다.

<br/><br/>

## 상속

상속은 두 가지 관점에서 설계에 안좋은 영향을 미친다.

1. 상속이 캡슐화를 위반한다는 것.
2. 설계를 유연하지 못하게 만든다는 것이다.

```
상속의 가장 큰 문제점은 캡슐화를 위반한다는 것이다.
```



상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.

<br/>

`AmountDiscountMovie`와 `PercentDiscountMovie`를 구현하는 개발자는

부모 클래스인 `Movie`의 `calculateMovieFee` 메서드 안에서 추상 메서드인

`getDiscountAmount` 메서드를 호출한다는 사실까지 알고 있어야 한다는 것이다.

```
결과적으로 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화 깨진다.
```

<br/><br/>

## 합성

```
단순히 코드를 재사용하고 싶다면 합성을 고려해보자. 
```

`Movie`는 `DiscountPolicy`가 외부에 `calculateDiscountAmount` 메서드를 제공한다는 

사실만 알고 내부 구현에 대해서는 전혀 알지 못한다. 

<br/>

이처럼, 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 부른다.

인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에, 

구현을 효과적으로 캡슐화할 수 있다. 

<br/>

또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.

합성은 메시지를 통해 느슨하게 결합된다.

<br/>

따라서, 코드 재사용을 위해서는 상속보다는 합성을 선호나는 것이 더 좋은 방법이다.

```java
public interface RatePolicy {
    Money calculateFee(Phone phone);
}
```

<br/>

```java
public abstract class BasicRatePolicy implements RatePolicy {
    @Override
    public Money calculateFee(Phone phone) {
        Money result = Money.ZERO;

        for(Call call : phone.getCalls()) {
            result.plus(calculateCallFee(call));
        }

        return result;
    }

    abstract protected Money calculateCallFee(Call call);
}
```

<br/>

```java
public class RegularPolicy extends BasicRatePolicy {
    private Money amout;
    private Duration seconds;

    public RegularPolicy(Money amount, Duration seconds) {
        this.amount = amount;
        this.seconds = seconds;
    }

    @Override
    protected Money calculateCallFee(Call call) {
        return amount.times(call.getDuration().getSeconds() / seconds.getSeconds());
    }
}
```

<br/><br/>

## 정리

객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 

역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것이다.

<br/><br/>

>**Reference** 
> <br/> [오브젝트](http://www.yes24.com/Product/Goods/74219491)